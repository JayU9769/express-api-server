{"version":3,"sources":["../../../src/services/permission.service.ts"],"sourcesContent":["import { Service } from 'typedi';\nimport { HttpException } from '@/exceptions/HttpException';\nimport { Permission, Prisma, RoleHasPermission } from '@prisma/client';\nimport { BaseService } from '@/services/base/base.service';\nimport { EUserType, TRecord } from '@/interfaces/global.interface';\nimport { IUpdatePermission } from '@/interfaces/permission.interface';\nimport { RedisService } from '@/config/redis';\n\n/**\n * Service class for handling permission-related operations.\n * Extends the base service for CRUD functionality specific to the Permission model.\n */\n@Service()\nexport class PermissionService extends BaseService<Permission> {\n  // Singleton instance of Redis service for caching purposes\n  private redis = RedisService.getInstance();\n\n  /**\n   * Constructor initializes the base service with the 'Permission' model name.\n   */\n  constructor() {\n    super('Permission'); // Passes the model name to the base service\n  }\n\n  // Prisma query to interact with the permission table\n  public query = this.prisma.permission;\n\n  /**\n   * Retrieves all permissions from the database, optionally filtered by user type.\n   * @param {EUserType} [type] - Optional type filter for permissions.\n   * @returns {Promise<Permission[]>} - A promise that resolves to an array of permissions.\n   */\n  public async findAll(type?: EUserType): Promise<Permission[]> {\n    const whereCondition: any = {};\n    if (type) {\n      whereCondition.type = type; // Add type condition if specified\n    }\n    return this.prisma.permission.findMany({\n      where: whereCondition,\n    });\n  }\n\n  /**\n   * Retrieves all role-permission relationships from the database.\n   * @returns {Promise<RoleHasPermission[]>} - A promise that resolves to an array of role-permission relationships.\n   */\n  public async findAllRoleHasPermissions(): Promise<RoleHasPermission[]> {\n    return this.prisma.roleHasPermission.findMany();\n  }\n\n  /**\n   * Updates role permissions based on provided data. Adds or removes role-permission relationships.\n   * @param {IUpdatePermission} data - Data containing role, permission, and action (add/remove).\n   */\n  public async updatePermission(data: IUpdatePermission) {\n    const { role, value, permission } = data;\n\n    const tempRole = await this.prisma.role.findUnique({ where: { id: role.id, isSystem: 1 } });\n\n    if (tempRole) throw new HttpException(422, 'Can not change permissions of System roles');\n\n    // If the permission has no parentId, find its child permissions\n    const permissions = permission.parentId ? [permission] : await this.prisma.permission.findMany({ where: { parentId: permission.id } });\n\n    // Map permissions to create role-permission relationships\n    const rolesWithPermissions: RoleHasPermission[] = permissions.map(p => ({\n      roleId: role.id,\n      permissionId: p.id,\n    }));\n\n    // If there are no permissions, exit early\n    if (rolesWithPermissions.length === 0) return;\n\n    // If value is true, add role-permission relationships, otherwise delete them\n    value\n      ? await this.prisma.roleHasPermission.createMany({\n          data: rolesWithPermissions,\n          skipDuplicates: true,\n        })\n      : await this.prisma.roleHasPermission.deleteMany({\n          where: {\n            OR: rolesWithPermissions.map(({ roleId, permissionId }) => ({\n              roleId,\n              permissionId,\n            })),\n          },\n        });\n\n    // Refresh cached permissions\n    this.getPermissions(true);\n  }\n\n  /**\n   * Retrieves permissions from the database, grouped by role type and role name.\n   * If cached data exists, it returns the cached data unless the `forceUpdate` flag is set to true.\n   *\n   * @param {boolean} forceUpdate - Optional flag to force cache update. If true, data will be fetched from the database and the cache will be updated.\n   * @returns {Promise<TRecord>} - A promise that resolves to a record of permissions grouped by role type and role name.\n   */\n  public async getPermissions(forceUpdate: boolean = false): Promise<TRecord> {\n    // Check if the permissions are cached and return from cache if not forced to update\n    const cachedPermissions = await this.redis.get('permissions');\n    if (cachedPermissions && !forceUpdate) {\n      return JSON.parse(cachedPermissions) as TRecord;\n    }\n\n    // Fetch permissions from the database\n    const permissions: TRecord = {};\n    const rolesWithPermissions = await this.prisma.role.findMany({\n      include: {\n        roleHasPermissions: {\n          include: {\n            permission: true, // Include permission details in the role-permission relationship\n          },\n        },\n      },\n    });\n\n    // Group permissions by role type and role name\n    if (rolesWithPermissions.length > 0) {\n      rolesWithPermissions.forEach(role => {\n        if (!permissions[role.type]) {\n          permissions[role.type] = {};\n        }\n        permissions[role.type][role.name] = role.roleHasPermissions.map(rhp => rhp.permission.name);\n      });\n\n      // Cache the new permissions data in Redis\n      await this.redis.set('permissions', JSON.stringify(permissions));\n    }\n\n    return permissions;\n  }\n\n  /**\n   * Finds a permission by its unique ID.\n   * @param {string} permissionId - The ID of the permission to find.\n   * @returns {Promise<Permission>} - A promise that resolves to the found permission or throws an exception if not found.\n   * @throws {HttpException} - Throws an exception if the permission does not exist.\n   */\n  public async findById(permissionId: string): Promise<Permission> {\n    const findPermission: Permission = await this.prisma.permission.findUnique({\n      where: { id: permissionId },\n    });\n    if (!findPermission) throw new HttpException(409, \"Permission doesn't exist\");\n\n    return findPermission;\n  }\n\n  /**\n   * Creates a new permission with the provided data.\n   * @param {Permission} data - The permission data to create.\n   * @returns {Promise<Permission>} - A promise that resolves to the created permission.\n   * @throws {HttpException} - Throws an exception if the permission name already exists.\n   */\n  public async create(data: Permission): Promise<Permission> {\n    // Check if a permission with the same name already exists\n    const findPermission: Permission = await this.prisma.permission.findUnique({\n      where: { name: data.name },\n    });\n    if (findPermission) throw new HttpException(409, `This permission ${data.name} already exists`);\n\n    // Remove ID field and create a new permission\n    delete data.id;\n    return this.prisma.permission.create({ data });\n  }\n\n  /**\n   * Updates an existing permission by its ID with the provided data.\n   * Validates that the permission name is unique across permissions.\n   * @param {string} permissionId - The ID of the permission to update.\n   * @param {Permission} data - The new data for the permission.\n   * @returns {Promise<Permission>} - A promise that resolves to the updated permission.\n   * @throws {HttpException} - Throws an exception if the permission name already exists for a different permission.\n   * @throws {HttpException} - Throws an exception if the permission with the provided ID is not found.\n   */\n  public async update(permissionId: string, data: Permission): Promise<Permission> {\n    // Find the permission by ID to ensure the permission exists\n    const findPermission: Permission | null = await this.prisma.permission.findUnique({\n      where: { id: permissionId },\n    });\n\n    // Throw an error if the permission is not found\n    if (!findPermission) {\n      throw new HttpException(404, `Permission with ID ${permissionId} not found`);\n    }\n\n    // Check if another permission with the same name exists\n    if (data.name && data.name.toLowerCase() !== findPermission.name.toLowerCase()) {\n      const existingPermissionWithName: Permission | null = await this.prisma.permission.findUnique({\n        where: { name: data.name },\n      });\n\n      // Throw an error if a permission with the same name exists\n      if (existingPermissionWithName) {\n        throw new HttpException(409, `Permission name ${data.name} is already in use by another permission`);\n      }\n    }\n\n    // Update the permission with the new data\n    return this.prisma.permission.update({\n      where: { id: permissionId },\n      data: data,\n    });\n  }\n\n  /**\n   * Deletes permissions by their IDs.\n   * @param {string[]} permissionIds - An array of permission IDs to delete.\n   * @returns {Promise<boolean>} - A promise that resolves to true if permissions were successfully deleted.\n   * @throws {HttpException} - Throws an exception if no permissions were deleted.\n   */\n  public async delete(permissionIds: string[]): Promise<boolean> {\n    // Delete permissions by their IDs\n    const result = await this.prisma.permission.deleteMany({\n      where: {\n        id: { in: permissionIds },\n      },\n    });\n\n    // Throw an error if no permissions were deleted\n    if (!result.count) throw new HttpException(409, \"Permission doesn't exist\");\n\n    return true;\n  }\n}\n"],"names":["PermissionService","BaseService","findAll","type","whereCondition","prisma","permission","findMany","where","findAllRoleHasPermissions","roleHasPermission","updatePermission","data","role","value","tempRole","findUnique","id","isSystem","HttpException","permissions","parentId","rolesWithPermissions","map","p","roleId","permissionId","length","createMany","skipDuplicates","deleteMany","OR","getPermissions","forceUpdate","cachedPermissions","redis","get","JSON","parse","include","roleHasPermissions","forEach","name","rhp","set","stringify","findById","findPermission","create","update","toLowerCase","existingPermissionWithName","delete","permissionIds","result","in","count","constructor","RedisService","getInstance","query"],"mappings":"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"}
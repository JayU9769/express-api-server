{"version":3,"sources":["../../../src/services/admin.service.ts"],"sourcesContent":["import { hash } from 'bcrypt';\nimport { Service } from 'typedi';\nimport { HttpException } from '@/exceptions/HttpException';\nimport { Admin } from '@prisma/client';\nimport { BaseService } from '@/services/base/base.service';\nimport bcrypt from 'bcryptjs';\n\n/**\n * Service class for handling user-related operations.\n * Extends the base service for CRUD functionality specific to the User model.\n */\n@Service()\nexport class AdminService extends BaseService<Admin> {\n  /**\n   * Constructor initializes the base service with the 'User' model name.\n   */\n  constructor() {\n    super('Admin');\n  }\n\n  public query = this.prisma.admin;\n\n  /**\n   * Retrieves all users from the database.\n   * @returns {Promise<User[]>} - A promise that resolves to an array of users.\n   */\n  public async findAll(): Promise<Admin[]> {\n    return this.prisma.admin.findMany();\n  }\n\n  /**\n   * Finds a user by their unique ID.\n   * @param {string} userId - The ID of the user to find.\n   * @returns {Promise<User>} - A promise that resolves to the found user or throws an exception if not found.\n   * @throws {HttpException} - Throws an exception if the user does not exist.\n   */\n  public async findById(userId: string): Promise<Admin> {\n    const findUser: Admin = await this.prisma.admin.findUnique({\n      where: { id: userId },\n    });\n    if (!findUser) throw new HttpException(409, \"User doesn't exist\");\n\n    return findUser;\n  }\n\n  /**\n   * Creates a new user with the provided data.\n   * Hashes the password before saving the user in the database.\n   * @param {User} data - The user data to create.\n   * @returns {Promise<User>} - A promise that resolves to the created user.\n   * @throws {HttpException} - Throws an exception if the email already exists.\n   */\n  public async create(data: Admin): Promise<Admin> {\n    // Check if user already exists by email\n    const findUser: Admin = await this.prisma.admin.findUnique({\n      where: { email: data.email },\n    });\n\n    if (findUser) throw new HttpException(409, `This email ${data.email} already exists`);\n\n    // Hash the user's password\n    const hashedPassword = await hash(data.password, 10);\n\n    // Create the user with the hashed password\n    delete data.id;\n    const admin = await this.prisma.admin.create({\n      data: { ...data, password: hashedPassword },\n    });\n    return admin;\n  }\n  /**\n   * Updates an existing user by their ID with the provided data.\n   * If the password is updated, it is hashed before saving.\n   * Validates that the email is unique across users.\n   * @param {string} userId - The ID of the user to update.\n   * @param {User} data - The new data for the user.\n   * @returns {Promise<User>} - A promise that resolves to the updated user.\n   * @throws {HttpException} - Throws an exception if the email already exists for a different user.\n   * @throws {HttpException} - Throws an exception if the user with the provided ID is not found.\n   */\n  public async update(userId: string, data: Admin): Promise<Admin> {\n    // Find the user by ID to ensure the user exists\n    const findUser: Admin | null = await this.prisma.admin.findUnique({\n      where: { id: userId },\n    });\n\n    // Throw an error if unable to find user with userId\n    if (!findUser) {\n      throw new HttpException(404, `User with ID ${userId} not found`);\n    }\n\n    // Check if another user exists with the same email but a different ID\n    if (data.email && data.email.toLowerCase() !== findUser.email.toLowerCase()) {\n      const existingUserWithEmail: Admin | null = await this.prisma.admin.findUnique({\n        where: { email: data.email },\n      });\n\n      // Throw an error if an existing user with the same email is found\n      if (existingUserWithEmail) {\n        throw new HttpException(409, `Email ${data.email} is already in use by another user`);\n      }\n    }\n\n    // Update the user with new data\n    return await this.prisma.admin.update({\n      where: { id: userId },\n      data: data,\n    });\n  }\n\n  /**\n   * Deletes users by their IDs.\n   * @param {string[]} userIds - An array of user IDs to delete.\n   * @returns {Promise<boolean>} - A promise that resolves to true if users were successfully deleted.\n   * @throws {HttpException} - Throws an exception if no users were deleted.\n   */\n  public async delete(userIds: string[]): Promise<boolean> {\n    // Attempt to delete users with the provided IDs\n    const result = await this.prisma.admin.deleteMany({\n      where: {\n        id: { in: userIds },\n        isSystem: 0,\n      },\n    });\n\n    // Throw an error if no users were deleted\n    if (!result.count) throw new HttpException(409, \"User doesn't exist\");\n\n    return true;\n  }\n\n  // Update admin profile\n  public async updateProfile(adminId: string, name: string, email: string): Promise<Admin> {\n    return this.prisma.admin.update({\n      where: { id: adminId },\n      data: { name, email },\n    });\n  }\n\n  // Update admin password\n  public async updatePassword(adminId: string, currentPassword: string, newPassword: string): Promise<void> {\n    const admin = await this.prisma.admin.findUnique({ where: { id: adminId } });\n\n    if (!admin) {\n      throw new Error('Admin not found');\n    }\n\n    const isMatch = await bcrypt.compare(currentPassword, admin.password);\n    if (!isMatch) {\n      throw new Error('Current password is incorrect');\n    }\n\n    const isNewMatch = await bcrypt.compare(newPassword, admin.password);\n    if (isNewMatch) {\n      throw new Error('New password is already used in the past');\n    }\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n\n    await this.prisma.admin.update({\n      where: { id: adminId },\n      data: { password: hashedPassword },\n    });\n  }\n\n  public async updatePasswordWithoutCurrent(adminId: string, newPassword: string): Promise<void> {\n    const admin = await this.prisma.admin.findUnique({ where: { id: adminId } });\n\n    if (!admin) {\n      throw new Error('Admin not found');\n    }\n\n    const isNewMatch = await bcrypt.compare(newPassword, admin.password);\n    if (isNewMatch) {\n      throw new Error('New password is already used in the past');\n    }\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n\n    await this.prisma.admin.update({\n      where: { id: adminId },\n      data: { password: hashedPassword },\n    });\n  }\n}\n"],"names":["AdminService","BaseService","findAll","prisma","admin","findMany","findById","userId","findUser","findUnique","where","id","HttpException","create","data","email","hashedPassword","hash","password","update","toLowerCase","existingUserWithEmail","delete","userIds","result","deleteMany","in","isSystem","count","updateProfile","adminId","name","updatePassword","currentPassword","newPassword","Error","isMatch","bcrypt","compare","isNewMatch","updatePasswordWithoutCurrent","constructor","query"],"mappings":"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"}
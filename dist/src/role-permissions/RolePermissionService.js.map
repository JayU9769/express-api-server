{"version":3,"sources":["../../../src/role-permissions/RolePermissionService.ts"],"sourcesContent":["import { PrismaClient, UserType } from '@prisma/client';\nimport NodeCache from 'node-cache';\nimport { Service } from 'typedi';\n\nconst prisma = new PrismaClient();\n\n// Cache with a TTL of 60 seconds (for example)\nconst rolePermissionCache = new NodeCache({ stdTTL: 60 });\n/**\n * Service class for handling user-related operations.\n * Extends the base service for CRUD functionality specific to the User model.\n */\n@Service()\nclass RolePermissionService {\n  /**\n   * Synchronize roles for a given modelId with the provided array of roles.\n   * @param modelId The ID of the model to synchronize roles for.\n   * @param roleIds\n   * @param modelType The type of the model (UserType).\n   */\n  async syncRoles(modelId: string, roleIds: string[], modelType: UserType) {\n    // Fetch the existing role associations for the given modelId and modelType\n    const existingRoles = await prisma.modelHasRole.findMany({\n      where: {\n        modelId,\n        modelType,\n      },\n    });\n\n    // Extract the role IDs from the existing associations\n    const existingRoleIds = existingRoles.map(r => r.roleId);\n\n    // Roles to be added (present in 'roleIds' but not in 'existingRoleIds')\n    const rolesToAdd = roleIds.filter(roleId => !existingRoleIds.includes(roleId));\n\n    // Roles to be removed (present in 'existingRoleIds' but not in 'roleIds')\n    const rolesToRemove = existingRoleIds.filter(roleId => !roleIds.includes(roleId));\n\n    // Remove roles that should no longer be associated with the modelId\n    if (rolesToRemove.length > 0) {\n      await prisma.modelHasRole.deleteMany({\n        where: {\n          modelId: modelId,\n          modelType: modelType,\n          roleId: { in: rolesToRemove },\n        },\n      });\n    }\n\n    // Add roles that are missing\n    if (rolesToAdd.length > 0) {\n      const roleAssociations = rolesToAdd.map(roleId => ({\n        modelId: modelId,\n        roleId: roleId,\n        modelType: modelType,\n      }));\n\n      await prisma.modelHasRole.createMany({\n        data: roleAssociations,\n      });\n    }\n\n    // Invalidate cache after synchronization\n    this.invalidateCache(modelId, modelType);\n  }\n\n  /**\n   * Assign a role to a user or admin.\n   */\n  async assignRole(modelId: string, roleId: string, modelType: UserType) {\n    const role = await prisma.role.findUnique({\n      where: { id: roleId },\n    });\n\n    if (!role) {\n      throw new Error(`Role ${role.name} does not exist`);\n    }\n\n    await prisma.modelHasRole.create({\n      data: {\n        roleId: role.id,\n        modelId,\n        modelType,\n      },\n    });\n\n    this.invalidateCache(modelId, modelType); // Invalidate cache after assignment\n  }\n\n  /**\n   * Assign a permission to a role.\n   */\n  async assignPermissionToRole(roleId: string, permissionId: string) {\n    await prisma.roleHasPermission.create({\n      data: {\n        roleId,\n        permissionId,\n      },\n    });\n  }\n\n  /**\n   * Assign a permission directly to a user or admin.\n   */\n  async assignPermissionToUser(modelId: string, permissionId: string, modelType: UserType) {\n    // Create a user-specific role if it doesn't exist\n    const userSpecificRole = await prisma.role.findFirst({\n      where: {\n        name: `${modelType}_specific_${modelId}`,\n        type: modelType,\n      },\n    });\n\n    let roleId: string;\n\n    if (!userSpecificRole) {\n      const newRole = await prisma.role.create({\n        data: {\n          name: `${modelType}_specific_${modelId}`,\n          type: modelType,\n        },\n      });\n      roleId = newRole.id;\n      await this.assignRole(modelId, newRole.id, modelType); // Assign the new role to the user/admin\n    } else {\n      roleId = userSpecificRole.id;\n    }\n\n    // Now assign the permission to this specific role\n    await this.assignPermissionToRole(roleId, permissionId);\n    this.invalidateCache(modelId, modelType); // Invalidate cache\n  }\n\n  /**\n   * Check if a user/admin has a specific role.\n   */\n  async hasRole(modelId: string, roleName: string, modelType: UserType): Promise<boolean> {\n    const cacheKey = `${modelType}_roles_${modelId}`;\n    const cachedRoles = rolePermissionCache.get<string[]>(cacheKey);\n\n    if (cachedRoles) {\n      return cachedRoles.includes(roleName);\n    }\n\n    // Query the roles from the database if not cached\n    const roles = await prisma.modelHasRole.findMany({\n      where: {\n        modelId,\n        modelType,\n      },\n      include: {\n        role: true,\n      },\n    });\n\n    const roleNames = roles.map(r => r.role.name);\n    rolePermissionCache.set(cacheKey, roleNames); // Cache the roles\n    return roleNames.includes(roleName);\n  }\n\n  /**\n   * Check if a user/admin has a specific permission.\n   */\n  async hasPermission(modelId: string, permissionName: string, modelType: UserType): Promise<boolean> {\n    const cacheKey = `${modelType}_permissions_${modelId}`;\n    const cachedPermissions = rolePermissionCache.get<string[]>(cacheKey);\n\n    if (cachedPermissions) {\n      return cachedPermissions.includes(permissionName);\n    }\n\n    // Query the permissions from the database if not cached\n    const roles = await prisma.modelHasRole.findMany({\n      where: {\n        modelId,\n        modelType,\n      },\n      include: {\n        role: {\n          include: {\n            roleHasPermissions: {\n              include: {\n                permission: true,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    const permissions = roles.flatMap(role => role.role.roleHasPermissions.map(rp => rp.permission.name));\n    rolePermissionCache.set(cacheKey, permissions); // Cache the permissions\n    return permissions.includes(permissionName);\n  }\n\n  async getRoles(modelId: string, modelType: UserType): Promise<{ id: string; name: string }[]> {\n    const cacheKey = `${modelType}_roles_${modelId}`;\n\n    // Check if the roles are cached\n    const cachedRoles = rolePermissionCache.get<{ id: string; name: string }[]>(cacheKey);\n\n    if (cachedRoles) {\n      return cachedRoles;\n    }\n\n    // Fetch the roles from the database\n    const roles = await prisma.modelHasRole.findMany({\n      where: {\n        modelId,\n        modelType,\n      },\n      include: {\n        role: true, // Include the role details\n      },\n    });\n\n    // Extract role ids and names\n    const roleData = roles.map(r => ({\n      id: r.role.id,\n      name: r.role.name,\n    }));\n\n    // Cache the role data for future use\n    rolePermissionCache.set(cacheKey, roleData);\n\n    return roleData;\n  }\n\n  /**\n   * Invalidate cache when roles/permissions are updated.\n   */\n  invalidateCache(modelId: string, modelType: UserType) {\n    rolePermissionCache.del(`${modelType}_roles_${modelId}`);\n    rolePermissionCache.del(`${modelType}_permissions_${modelId}`);\n  }\n}\n\nexport default RolePermissionService;\n"],"names":["prisma","PrismaClient","rolePermissionCache","NodeCache","stdTTL","RolePermissionService","syncRoles","modelId","roleIds","modelType","existingRoles","modelHasRole","findMany","where","existingRoleIds","map","r","roleId","rolesToAdd","filter","includes","rolesToRemove","length","deleteMany","in","roleAssociations","createMany","data","invalidateCache","assignRole","role","findUnique","id","Error","name","create","assignPermissionToRole","permissionId","roleHasPermission","assignPermissionToUser","userSpecificRole","findFirst","type","newRole","hasRole","roleName","cacheKey","cachedRoles","get","roles","include","roleNames","set","hasPermission","permissionName","cachedPermissions","roleHasPermissions","permission","permissions","flatMap","rp","getRoles","roleData","del"],"mappings":"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"}
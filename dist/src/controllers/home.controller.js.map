{"version":3,"sources":["../../../src/controllers/home.controller.ts"],"sourcesContent":["import { RoleService } from '@/services/role.service';\nimport { UserService } from '@/services/user.service';\nimport { PrismaClient } from '@prisma/client';\nimport { NextFunction, Request, Response } from 'express';\nimport Container from 'typedi';\n\n/**\n * Controller handling admin-related HTTP requests.\n */\nexport class HomeController {\n  private roleService = Container.get(RoleService);\n  private userService = Container.get(UserService);\n\n  /**\n   * @description Handles search list API.\n   * @param req - Express request object.\n   * @param res - Express response object.\n   * @param next - Express next function to pass control to the next middleware.\n   * @returns A JSON response with a success message and admin data or an error.\n   */\n  public searchList = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { type, q } = req.query;\n      const searchTerm = (q as string)?.toLowerCase() || '';\n\n      if (!type) {\n        return res.status(400).json({ message: 'Type is required', data: [] });\n      }\n\n      const searchResults = await this.getSearchResults(type as string, searchTerm);\n      const message = searchResults.length > 0 ? `${(type as string)?.charAt(0).toUpperCase() + (type as string)?.slice(1)} Fetch` : 'Not Found';\n\n      return res.status(200).json({ data: searchResults, message });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  /**\n   * @description Handles search value API.\n   * @param req - Express request object.\n   * @param res - Express response object.\n   * @param next - Express next function to pass control to the next middleware.\n   * @returns A JSON response with a success message and admin data or an error.\n   */\n  public searchValue = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { type, value } = req.query;\n\n      if (!type) {\n        return res.status(400).json({ message: 'Type is required', data: [] });\n      }\n\n      const searchValue = await this.getSearchValue(type as string, value as string);\n\n      const message = searchValue ? `${(type as string)?.charAt(0).toUpperCase() + (type as string)?.slice(1)} Found` : 'Not Found';\n\n      return res.status(200).json({ data: searchValue, message });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  /**\n   * Retrieves search results based on type and search term.\n   * @param type - The type of data to search for (roles or users).\n   * @param searchTerm - The search keyword in lowercase.\n   * @returns A list of formatted search results.\n   */\n  private getSearchResults = async (type: string, searchTerm: string) => {\n    let items = [];\n    let textKey = 'name'; // Default key for text\n\n    switch (type) {\n      case 'roles':\n        items = await this.roleService.query.findMany({\n          select: { id: true, name: true },\n          where: { status: 1, ...(searchTerm && { name: { startsWith: searchTerm } }) },\n          orderBy: { name: 'asc' },\n          take: 25,\n        });\n        textKey = 'name';\n        break;\n\n      case 'users':\n        items = await this.userService.query.findMany({\n          select: { id: true, name: true },\n          where: { status: 1, ...(searchTerm && { name: { contains: searchTerm } }) },\n          orderBy: { name: 'asc' },\n          take: 25,\n        });\n        textKey = 'name';\n        break;\n\n      default:\n        return [];\n    }\n\n    return this.mapList(items, { id: 'id', text: textKey });\n  };\n\n  /**\n   * Maps the items to the desired structure.\n   * @param items - The list of items.\n   * @param keys - Object mapping for id and textKey.\n   * @returns A mapped list of items.\n   */\n  private mapList(items: any[], { id, text }: { id: string; text: string }) {\n    return items.map(item => ({\n      value: item[id],\n      label: item[text], // Dynamically maps the `text` key\n    }));\n  }\n\n  private getSearchValue = async (type: string, value: string) => {\n    let item = {};\n    switch (type) {\n      case 'roles':\n        item = await this.roleService.findById(value);\n        return this.mapValue(item, { id: 'id', text: 'name' });\n        break;\n      case 'users':\n        item = await this.userService.findById(value);\n        return this.mapValue(item, { id: 'id', text: 'name' });\n      default:\n    }\n\n    return {};\n  };\n\n  private mapValue(item: any, { id, text }: { id: string; text: string }) {\n    return {\n      value: item[id],\n      label: item[text], // Dynamically maps the `text` key\n    };\n  }\n}\n"],"names":["HomeController","mapList","items","id","text","map","item","value","label","mapValue","roleService","Container","get","RoleService","userService","UserService","searchList","req","res","next","type","q","query","searchTerm","toLowerCase","status","json","message","data","searchResults","getSearchResults","length","charAt","toUpperCase","slice","error","searchValue","getSearchValue","textKey","findMany","select","name","where","startsWith","orderBy","take","contains","findById"],"mappings":"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"}